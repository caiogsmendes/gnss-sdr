/*!
 * \file control_thread.cc
 * \brief This class implements the receiver control plane
 * \author Carlos Aviles, 2010. carlos.avilesr(at)googlemail.com
 *
 * GNSS Receiver Control Plane: connects the flowgraph, starts running it,
 * and while it does not stop, reads the control messages generated by the blocks,
 * process them, and apply the corresponding actions.
 *
 * -----------------------------------------------------------------------------
 *
 * GNSS-SDR is a Global Navigation Satellite System software-defined receiver.
 * This file is part of GNSS-SDR.
 *
 * Copyright (C) 2010-2020  (see AUTHORS file for a list of contributors)
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 * -----------------------------------------------------------------------------
 */

#if ARMA_NO_BOUND_CHECKING
#define ARMA_NO_DEBUG 1
#endif

#include "control_thread.h"
#include "concurrent_map.h"
#include "configuration_interface.h"
#include "file_configuration.h"
#include "galileo_almanac.h"
#include "galileo_ephemeris.h"
#include "galileo_iono.h"
#include "galileo_utc_model.h"
#include "geofunctions.h"
#include "glonass_gnav_ephemeris.h"
#include "glonass_gnav_utc_model.h"
#include "gnss_flowgraph.h"
#include "gnss_satellite.h"
#include "gnss_sdr_flags.h"
#include "gps_acq_assist.h"        // for Gps_Acq_Assist
#include "gps_almanac.h"           // for Gps_Almanac
#include "gps_cnav_ephemeris.h"    // for Gps_CNAV_Ephemeris
#include "gps_cnav_utc_model.h"    // for Gps_CNAV_Utc_Model
#include "gps_ephemeris.h"         // for Gps_Ephemeris
#include "gps_iono.h"              // for Gps_Iono
#include "gps_utc_model.h"         // for Gps_Utc_Model
#include "pvt_interface.h"         // for PvtInterface
#include "rtklib.h"                // for gtime_t, alm_t
#include "rtklib_conversions.h"    // for alm_to_rtklib
#include "rtklib_ephemeris.h"      // for alm2pos, eph2pos
#include "rtklib_rtkcmn.h"         // for utc2gpst
#include <armadillo>               // for interaction with geofunctions
#include <boost/lexical_cast.hpp>  // for bad_lexical_cast
#include <glog/logging.h>          // for LOG
#include <pmt/pmt.h>               // for make_any
#include <algorithm>               // for find, min
#include <chrono>                  // for milliseconds
#include <cmath>                   // for floor, fmod, log
#include <ctime>                   // for time_t, gmtime, strftime
#include <exception>               // for exception
#include <iostream>                // for operator<<
#include <limits>                  // for numeric_limits
#include <map>                     // for map
#include <pthread.h>               // for pthread_cancel
#include <stdexcept>               // for invalid_argument
#include <sys/ipc.h>               // for IPC_CREAT
#include <sys/msg.h>               // for msgctl, msgget

// Caio
#include "display.h"
#include "serial_cmd_interface.h"
#include <string.h>
#include "HEtechSerial.h"
#include <gpiod.h>
//

#ifdef ENABLE_FPGA
#include <boost/chrono.hpp>  // for steady_clock
#endif

#if PMT_USES_BOOST_ANY
namespace wht = boost;
#else
namespace wht = std;
#endif

extern Concurrent_Map<Gps_Acq_Assist> global_gps_acq_assist_map;
extern Concurrent_Queue<Gps_Acq_Assist> global_gps_acq_assist_queue;


ControlThread::ControlThread()
{
    if (FLAGS_c == "-")
        {
            configuration_ = std::make_shared<FileConfiguration>(FLAGS_config_file);
        }
    else
        {
            configuration_ = std::make_shared<FileConfiguration>(FLAGS_c);
        }
    // Basic configuration checks
    auto aux = std::dynamic_pointer_cast<FileConfiguration>(configuration_);
    conf_file_has_section_ = aux->has_section();

    conf_file_has_mandatory_globals_ = (configuration_->property("GNSS-SDR.internal_fs_sps", 0) == 0 ? false : true);

    const std::string empty_implementation;
    std::string src_impl = configuration_->property("SignalSource.implementation", empty_implementation);
    int src_count_deprecated = configuration_->property("Receiver.sources_count", 1);
    int src_count = configuration_->property("GNSS-SDR.num_sources", src_count_deprecated);
    if (src_impl.empty())
        {
            src_impl = std::string("");
            int num_src = 0;
            for (auto i = 0; i < src_count; i++)
                {
                    auto src_impl_multiple = configuration_->property("SignalSource" + std::to_string(i) + ".implementation", empty_implementation);
                    num_src += !src_impl_multiple.empty();
                }
            conf_has_signal_sources_ = (num_src == src_count);
        }
    else
        {
            conf_has_signal_sources_ = true;
        }

    std::string pvt_impl = configuration_->property("PVT.implementation", empty_implementation);
    conf_has_pvt_ = !pvt_impl.empty();

    std::string obs_impl = configuration_->property("Observables.implementation", empty_implementation);
    conf_has_observables_ = !obs_impl.empty();

    well_formatted_configuration_ = conf_file_has_section_ && conf_file_has_mandatory_globals_ && conf_has_signal_sources_ && conf_has_observables_ && conf_has_pvt_;

    restart_ = false;
    init();
}


ControlThread::ControlThread(std::shared_ptr<ConfigurationInterface> configuration)
    : configuration_(std::move(configuration)),
      well_formatted_configuration_(true),
      conf_file_has_section_(true),
      conf_file_has_mandatory_globals_(true),
      conf_has_signal_sources_(true),
      conf_has_observables_(true),
      conf_has_pvt_(true),
      restart_(false)
{
    init();
}


void ControlThread::init()
{
    telecommand_enabled_ = configuration_->property("GNSS-SDR.telecommand_enabled", false);
    // serialcmd_enabled_ = configuration_->property("GNSS-SDR.serial_cmd_enabled", true);  // Caio: Default seria off, mas pra teste, true.
    serialcmd_enabled_=true;
    // OPTIONAL: specify a custom year to override the system time in order to postprocess old gnss records and avoid wrong week rollover
    pre_2009_file_ = configuration_->property("GNSS-SDR.pre_2009_file", false);
    // Instantiates a control queue, a GNSS flowgraph, and a control message factory
    control_queue_ = std::make_shared<Concurrent_Queue<pmt::pmt_t>>();
    cmd_interface_.set_msg_queue(control_queue_);  // set also the queue pointer for the telecommand thread

    /** ###########################################################################
     * Caio -> copiei para a função de cmd serial.
     */
    //    serial_control_queue_ = std::make_shared<Concurrent_Queue<pmt::pmt_t>>();
    // std::cout << TEXT_BOLD_BLUE << "Caio: Control Thread Init()" << TEXT_RESET
            //   << "\n";
    
    serial_cmd_interface_.set_msg_queue(control_queue_);
    // serial_cmd_interface_.set_channels(flowgraph_->get_channels());
    // serial_synchro_interface_.set_channels(channel_status_->get_current_status_map());
    // char device[] = {"/dev/ttyUSB0"};
    // char device[] = {"/dev/ttyLP2"};
    /* | O_NOCTTY | O_NDELAY | O_NONBLOCK */
    // comms = HEserial_connect( &device[0], B115200, O_RDWR);
    // RGL_ctrl_
    // ###########################################################################
    // // std::cout<<sizeof(uint16_t)<<"\n";
    if (well_formatted_configuration_)
        {
            try
                {
                    flowgraph_ = std::make_shared<GNSSFlowgraph>(configuration_, control_queue_);
                    // Isso cria uma redundancia e uma concorrencia pelo msm recurso (port)
                    // serial_cmd_flowgraph_ = std::make_shared<GNSSFlowgraph>(configuration_, control_queue_);
                }
            catch (const boost::bad_lexical_cast &e)
                {
                    // std::cout << "Caught bad lexical cast with error " << e.what() << '\n';
                }
        }
    else
        {
            flowgraph_ = nullptr;
        }

    stop_ = false;
    processed_control_messages_ = 0;
    applied_actions_ = 0;
    supl_mcc_ = 0;
    supl_mns_ = 0;
    supl_lac_ = 0;
    supl_ci_ = 0;
    msqid_ = -1;
    agnss_ref_location_ = Agnss_Ref_Location();
    agnss_ref_time_ = Agnss_Ref_Time();

    const std::string empty_string;
    const std::string ref_location_str = configuration_->property("GNSS-SDR.AGNSS_ref_location", empty_string);
    const std::string ref_time_str = configuration_->property("GNSS-SDR.AGNSS_ref_utc_time", empty_string);
    if (ref_location_str != empty_string)
        {
            std::vector<double> vect;
            std::stringstream ss(ref_location_str);
            double d;
            while (ss >> d)
                {
                    vect.push_back(d);
                    if ((ss.peek() == ',') || (ss.peek() == ' '))
                        {
                            ss.ignore();
                        }
                }
            // fill agnss_ref_location_
            if (vect.size() >= 2)
                {
                    if ((vect[0] < 90.0) && (vect[0] > -90) && (vect[1] < 180.0) && (vect[1] > -180.0))
                        {
                            agnss_ref_location_.lat = vect[0];
                            agnss_ref_location_.lon = vect[1];
                            agnss_ref_location_.valid = true;
                        }
                    else
                        {
                            std::cerr << "GNSS-SDR.AGNSS_ref_location=" << ref_location_str << " is not a valid position.\n";
                            agnss_ref_location_.valid = false;
                        }
                }
        }
    if (ref_time_str == empty_string)
        {
            // Make an educated guess
            time_t rawtime;
            time(&rawtime);
            agnss_ref_time_.seconds = rawtime;
            agnss_ref_time_.valid = true;
        }
    else
        {
            // fill agnss_ref_time_
            struct tm tm
            {
            };
            if (strptime(ref_time_str.c_str(), "%d/%m/%Y %H:%M:%S", &tm) != nullptr)
                {
                    agnss_ref_time_.seconds = timegm(&tm);
                    if (agnss_ref_time_.seconds > 0)
                        {
                            agnss_ref_time_.valid = true;
                        }
                    else
                        {
                            std::cerr << "GNSS-SDR.AGNSS_ref_utc_time=" << ref_time_str << " is not well-formed. Please use four digits for the year: DD/MM/YYYY HH:MM:SS\n";
                        }
                }
            else
                {
                    std::cerr << "GNSS-SDR.AGNSS_ref_utc_time=" << ref_time_str << " is not well-formed. Should be DD/MM/YYYY HH:MM:SS in UTC\n";
                    agnss_ref_time_.valid = false;
                }
        }

    receiver_on_standby_ = false;
}


ControlThread::~ControlThread()  // NOLINT(modernize-use-equals-default)
{
    // DLOG(INFO) << "Control Thread destructor called";
    // flag_interrupt_PPS_sig = true;
    if (msqid_ != -1)
        {
            msgctl(msqid_, IPC_RMID, nullptr);
        }
    // if (sysv_queue_thread_.joinable())
    //     {
    //         sysv_queue_thread_.join();
    //     }
    if (cmd_interface_thread_.joinable())
        {
            cmd_interface_thread_.join();
        }
    // Caio - ControlThread Destructor -> fecha as threads
    if (serial_cmd_interface_thread_.joinable())
        {
            // std::cout << TEXT_BOLD_BLUE << "Caio: Thread join()" << TEXT_RESET << "\n";
            serial_cmd_interface_thread_.join();
        }
    // if (serial_cmd_interface_thread_w.joinable())
    //     {
    //         serial_cmd_interface_thread_w.join();
    //     }
    if (serial_timer_function_thread_.joinable())
        {
            serial_timer_function_thread_.join();
        }
    // if (PPS_siggen_thread_.joinable())
    // {
    //     PPS_siggen_thread_.join();
    // }
}


void ControlThread::telecommand_listener()
{
    if (telecommand_enabled_)
        {
            const int tcp_cmd_port = configuration_->property("GNSS-SDR.telecommand_tcp_port", 3333);
            cmd_interface_.run_cmd_server(tcp_cmd_port);
        }
}

void ControlThread::serialcmd_listener(void)
{
    // if (serialcmd_enabled_)
    //     {
    //         // std::cout << TEXT_BOLD_BLUE << "Caio Debug: Serial thread Listener..." << TEXT_RESET
    //                   << "\n";
    //         //  const char device = configuration_->property("GNSS-SDR.serial_device", "/dev/ttyUSB0");
    //         // char device[] = {"/dev/ttyUSB1"};
    //         // serial_s_t comms2 = HEserial_connect(&device[0], B115200, O_RDWR | O_NOCTTY | O_NDELAY | O_NONBLOCK);
    //         // char buff;
    //         // serial_cmd_interface_.run_serial_listener(&device[0], &buff, flowgraph_);
    // //         int lastcmd = 0xFF;
    // //         char test = 0x8d;
    //         // tcflush(comms.fd, TCIFLUSH);
    //         while (serialcmd_enabled_)
    //             {
    //                 // char msg{0};
    //                 int bitts;
    //                 // uint8_t msg;
    //                 uint8_t msg[2];
    //                 // int biit = HEserial_leitura_2(&comms,2);
    //                 uint8_t biit = 0;
    //                 biit= HEserial_leitura_byte(&comms);
    //                 // uint32_t cmd{0};
    //                 // Hex2IntegerAlt(&cmd, &msg);
    //                 if (biit == 223)
    //                     {
    //                         // serialcmd_enabled_ = false;
                            
    //                     }
    // //                 std::shared_ptr<PvtInterface> pvt_ptr = flowgraph_->get_pvt();
    // //                 std::map<int, Gps_Ephemeris> gps_map = pvt_ptr->get_gps_ephemeris();
    // //                 std::map<int, Gnss_Synchro> gnss_synchro = pvt_ptr->get_gnss_observables();
    // //                 double last_RX_time;
    // //                 // #################################
    // //                 tcflush(comms.fd, TCIFLUSH);
    // //                 // int result = 0;
    // //                 // comms.ufds.events = POLLIN;
    // //                 // while (result<8)
    // //                 //     {
    // //                 //         if (poll(&comms.ufds, 1, -1) > 0)
    // //                 //             {
    // //                 //                 if (comms.ufds.revents & POLLIN)
    // //                 //                     {
    // //                 //                         // result += read(comms.fd, &comms.rxbuff[result], sizeof(comms.rxbuff));
    // //                 //                         result += read(comms.fd, &comms.rxbuff[result], 8);
    // //                 //                         // memcpy(msg, &comm->rxbuff, sizeof(comm->rxbuff));  // Está Redundante ??
    // //                 //                     }
    // //                 //             }
    // //                 //     }
    // //                 // uint8_t cmd = HEserial_leitura_byte(&comms);
    // //                 // uint8_t cmd = comms.rxbuff[1];
    // //                 // int result = select(comms.fd+1,,NULL,NULL,&(tout));
    // //                 uint8_t cmd = 0xd5;
    // //                 // ########################################
    // //                 double longitude_deg;
    // //                 double latitude_deg;
    // //                 double height_m;
    // //                 time_t UTC_time;
    // //                 lastcmd = 0xd5;
    // //                 double tempoo;
    // //                 double variavelTempo;
    // //                 double diffSATREC;
    // //                 double diffSATSAT = 1000;
    // //                 double delta_tempo;
    // //                 double nvotempo;
    // //                 double limiar = 0.2;
    // //                 double rx_posX, rx_posY, rx_posZ;
    // //                 double rx_velX, rx_velY, rx_velZ;
    // //                 double gps_time_offset;
    // //                 int index = 0;
    // //                 double deltaprange{};
    // //                 // int num_sat = d_user_pvt_solver->get_num_valid_observations();
    // //                 int num_sat = pvt_ptr->get_num_sat_observ();
    // //                 int tam = num_sat * 65;
    // //                 uint8_t msgVec[tam];
    // //                 // Seleção de Modos:
    // //                 switch (cmd)
    // //                     {
    // //                     case 0x01:
    // //                         {  // Modo: HotStart
    // //                             tcflush(comms.fd, TCIFLUSH);
    // //                             int result = 0;
    // //                             comms.ufds.events = POLLIN;
    // //                             while (result < 34)
    // //                                 {
    // //                                     if (poll(&comms.ufds, 1, -1) > 0)
    // //                                         {
    // //                                             if (comms.ufds.revents & POLLIN)
    // //                                                 {
    // //                                                     // result += read(comms.fd, &comms.rxbuff[result], sizeof(comms.rxbuff));
    // //                                                     result += read(comms.fd, &comms.rxbuff[result], 34);
    // //                                                     // memcpy(msg, &comm->rxbuff, sizeof(comm->rxbuff));  // Está Redundante ??
    // //                                                 }
    // //                                         }
    // //                                 }
    // //                             int check = 0;for(int i=0;i<33;i++){check ^= comms.rxbuff[i];}
    // //                             if(comms.rxbuff[34] != check){break;}
    // //                             Hex2Double(&latitude_deg, &comms.rxbuff[9]);
    // //                             Hex2Double(&longitude_deg, &comms.rxbuff[17]);
    // //                             Hex2Double(&height_m, &comms.rxbuff[25]);
    // //                             break;
    // //                         }
    // //                     case 0x02:
    // //                         { // Modo: NavAux
    // //                             this->RGL_NavAux_enabled_=true;

    // //                             break;
    // //                         }
    // //                     case 0xd4:
    // //                         {
    // //                             /* code */
    // //                             lastcmd = 0xd4;
    // //                             // HEserial_envio(&comms, (uint8_t *)(&lastcmd));
    // //                             break;
    // //                         }
    // //                     case 0xd5:
    // //                         {
    // //                             /* code */
    // //                             double last_RX_time;
    // //                             for (const auto &y : gnss_synchro)
    // //                                 {
    // //                                     for (const auto &x : gps_map)
    // //                                         {
    // //                                             if (y.second.System == 'G')
    // //                                                 {
    // //                                                     last_RX_time = y.second.RX_time;
    // //                                                     if (y.second.PRN == x.second.PRN)
    // //                                                         {
    // //                                                             lastcmd = 0xd5;
    // //                                                             tempoo = y.second.RX_time;
    // //                                                             std::vector<double> LastSatPos(3);
    // //                                                             gps_map.at(x.first).satellitePosition(tempoo);
    // //                                                             if ((pvt_ptr->get_latest_PVT_(&longitude_deg,
    // //                                                                      &latitude_deg,
    // //                                                                      &height_m,
    // //                                                                      &UTC_time,
    // //                                                                      &gps_time_offset,
    // //                                                                      &rx_posX,
    // //                                                                      &rx_posY,
    // //                                                                      &rx_posZ,
    // //                                                                      &rx_velX,
    // //                                                                      &rx_velY,
    // //                                                                      &rx_velZ) == true))
    // //                                                                 {
    // //                                                                     //  Step 1
    // //                                                                     LastSatPos[0] = x.second.satpos_X;
    // //                                                                     LastSatPos[1] = x.second.satpos_Y;
    // //                                                                     LastSatPos[2] = x.second.satpos_Z;

    // //                                                                     while (diffSATSAT > limiar)
    // //                                                                         {
    // //                                                                             //  Step 2
    // //                                                                             diffSATREC = sqrt(
    // //                                                                                 (rx_posX - LastSatPos[0])*(rx_posX - LastSatPos[0])+
    // //                                                                                 (rx_posY - LastSatPos[1])*(rx_posY - LastSatPos[1])+
    // //                                                                                 (rx_posZ - LastSatPos[2])*(rx_posZ - LastSatPos[2]));
    // //                                                                             delta_tempo = diffSATREC / SPEED_OF_LIGHT_M_S;
    // //                                                                             // Step 3
    // //                                                                             nvotempo = tempoo - delta_tempo;
    // //                                                                             gps_map.at(x.first).satellitePosition(nvotempo);
    // //                                                                             diffSATSAT = sqrt(
    // //                                                                                 (LastSatPos[0] - x.second.satpos_X) * (LastSatPos[0] - x.second.satpos_X) +
    // //                                                                                 (LastSatPos[1] - x.second.satpos_Y) * (LastSatPos[1] - x.second.satpos_Y) +
    // //                                                                                 (LastSatPos[2] - x.second.satpos_Z) * (LastSatPos[2] - x.second.satpos_Z));
    // //                                                                             LastSatPos[0] = x.second.satpos_X;
    // //                                                                             LastSatPos[1] = x.second.satpos_Y;
    // //                                                                             LastSatPos[2] = x.second.satpos_Z;
    // //                                                                         }
    // //                                                                     // Step 4
    // //                                                                     variavelTempo = nvotempo - gps_time_offset;
    // //                                                                     gps_map.at(x.first).satellitePosition(variavelTempo);
    // //                                                                 }
    // //                                                                 deltaprange = -SPEED_OF_LIGHT_M_S*(y.second.Carrier_Doppler_hz/1575420000);
    // //                                                         Integer2Hex(&msgVec[index+0], &x.second.PRN);
    // //                                                         Double2Hex(&msgVec[index+1], &y.second.Pseudorange_m);
    // //                                                         Double2Hex(&msgVec[index + 9], &deltaprange);
    // //                                                         Double2Hex(&msgVec[index + 17], &x.second.satpos_X);
    // //                                                         Double2Hex(&msgVec[index + 25], &x.second.satpos_Y);
    // //                                                         Double2Hex(&msgVec[index + 33], &x.second.satpos_Z);
    // //                                                         Double2Hex(&msgVec[index + 41], &x.second.satvel_X);
    // //                                                         Double2Hex(&msgVec[index + 49], &x.second.satvel_Y);
    // //                                                         Double2Hex(&msgVec[index + 57], &x.second.satvel_Z);
    // //                                                         index = index + 65;
    // //                                                         }
    // //                                                 }
    // //                                         }
    // //                                 }
    // //                             for (int i = 0; i < index; i++)
    // //                                 {
    // //                                     msgVec[index + 1] = msgVec[index + 1] ^ msgVec[i]; //CRC
    // //                                 }
    // //                             HEserial_envio(&comms, &msgVec[0], &tam);
    // //                         }
    // //                         break;
    // //                     default:
    // //                         {
    // //                             {
    // //                                 // Standard Procedure
    // //                                 // serial_cmd_interface_pvt_.DersoProtocol();

    // //                                 break;
    // //                             }
    // //                         }
    // //                     }
    //             }
    //     }
}

void ControlThread::serialcmd_timer(void)
{
    // std::shared_ptr<PvtInterface> pvt_ptr = flowgraph_->get_pvt();
    // std::map<int, Gps_Ephemeris> gps_map = pvt_ptr->get_gps_ephemeris();
    // std::map<int, Gnss_Synchro> gnss_synchro = pvt_ptr->get_gnss_observables();
    // std::fstream arqtest("ephem_test3.txt", std::ios::app | std::ios::out);
    // std::fstream arqtestPVT("pvt_test3.txt", std::ios::app | std::ios::out);
    // auto tStartSteady = std::chrono::high_resolution_clock::now();
    // auto StartTime = tStartSteady;
    // int count = 1;
    // int contador{0};
    // double rx_posX, rx_posY, rx_posZ;
    // double rx_velX, rx_velY, rx_velZ;
    // double satPosX, satPosY, satPosZ;
    // double satVelX, satVelY, satVelZ;
    // time_t UTC_time;
    // double gdop, hdop, vdop, pdop;
    // int bytes;
    // int countad = 0;
    // int num_sat;
    // while (serialcmd_enabled_)
    //     {
    //         bytes = 0;
    //         //             num_sat = pvt_ptr->get_num_sat_observ();
    //         auto tEndSteady = std::chrono::high_resolution_clock::now();
    //         std::chrono::duration<double, std::milli> tempo_ligado_ms = tEndSteady - tStartSteady;
    //         //             // std::chrono::duration<double, std::micro> Uptempo1 = tEndSteady - tStartSteady;
    //         //             // std::chrono::duration<double, std::nano> Uptempo2 = tEndSteady - tStartSteady;
    //         //             double tempo_ligado_ms = Uptempo.count();
    //         //             // double tempo_ligado1 = Uptempo1.count();
    //         //             // double tempo_ligado2 = Uptempo2.count();
    //         //             // // std::cout<<std::setprecision(24)<< tempo_ligado_ms <<" ms || "<< tempo_ligado1 <<" us || "<<tempo_ligado2<<" ns"<<"\n";
    //         // std::chrono::milliseconds diff = tEndSteady - tStartSteady;
    //         // float tempo = diff.count();
    //         float tempo = tempo_ligado_ms.count();
    //         //             // std::time_t endWallTime = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    //         if (tempo >= 1000)
    //             {
    //                 //                     // // std::cout<< "tempo: "<<std::ctime(&endWallTime)<<"\n";
    //                 //                     // // std::cout<< diff.count()/1000000<<"\n";
    //                 //                     // sprintf(&buff[0],"Flag 1s, Count:%d \n",count++);
    //                 //                     // serial4send(&buff[0]);

    //                 // // std::cout << "Flag_1s_count: " << count++ << "\n";
    //                 tStartSteady = std::chrono::high_resolution_clock::now();
    //                 bool verif{false};
    //                 verif = pvt_ptr->got_first_fix();
    //                 if (verif || ((countad != 1) ? 0 : 1))
    //                     {
    //                         if ((countad != 1) && (verif))
    //                             {
    //                                 uint8_t bf[] = {0xDF, 0xDF};
    //                                 int siso = 2;
    //                                 int byt = HEserial_envio(&comms, &bf[0], &siso);
    //                                 // std::cout << "Bytes: " << byt << "\n";
    //                                 countad = 1;
    //                             }
    //                         if ((pvt_ptr->get_latest_PVT_2(&rx_posX,
    //                                  &rx_posY,
    //                                  &rx_posZ,
    //                                  &rx_velX,
    //                                  &rx_velY,
    //                                  &rx_velZ,
    //                                  &UTC_time,
    //                                  &gdop,
    //                                  &hdop,
    //                                  &vdop,
    //                                  &pdop) == true) &&
    //                             (countad == 1))
    //                             {
    //                                 arqtestPVT
    //                                     // << std::fixed << std::setprecision(4)
    //                                     // // std::cout
    //                                     << " "
    //                                     << rx_posX
    //                                     << " "
    //                                     << rx_posY
    //                                     << " "
    //                                     << rx_posZ
    //                                     << " "
    //                                     << rx_velX
    //                                     << " "
    //                                     << rx_velY
    //                                     << " "
    //                                     << rx_velZ;

    //                                 // #################################################################################################
    //                                 // #                               Só para efeitos de Debug                                        #
    //                                 // #################################################################################################
    //                                 // std::shared_ptr<PvtInterface> pvt_ptr = flowgraph_->get_pvt();
    //                                 gps_map = pvt_ptr->get_gps_ephemeris();
    //                                 gnss_synchro = pvt_ptr->get_gnss_observables();
    //                                 int num_sat = pvt_ptr->get_num_sat_observ();
    //                                 int tam = num_sat * 65 + 2;
    //                                 int msgSize = 52 + tam;
    //                                 uint8_t buff[msgSize]{0};
    //                                 // ############################    Primeira Msg - PVT (52 bytes Fixos)   ###########################
    //                                 // buff[0] = 0xd5;                                    // ,
    //                                 // Double2Hex(&buff[1], (double *)&tempo_ligado_ms);  // tem que ser em double
    //                                 // //
    //                                 // // Float2Hexx(&buff[9], 0x0000);   // modo
    //                                 // // Float2Hexx(&buff[17], 0x0000);  // Estado
    //                                 // //
    //                                 // buff[9] = 0x00;
    //                                 // buff[10] = 0x00;
    //                                 // Float2Hex(&buff[11], (float *)&gdop);  // Colocar os dops como float
    //                                 // Float2Hex(&buff[15], (float *)&hdop);
    //                                 // Float2Hex(&buff[19], (float *)&vdop);
    //                                 // Float2Hex(&buff[23], (float *)&pdop);
    //                                 // Float2Hex(&buff[27], (float *)&rx_posX);
    //                                 // Float2Hex(&buff[31], (float *)&rx_posY);
    //                                 // Float2Hex(&buff[35], (float *)&rx_posZ);
    //                                 // Float2Hex(&buff[39], (float *)&rx_velX);
    //                                 // Float2Hex(&buff[43], (float *)&rx_velY);
    //                                 // Float2Hex(&buff[47], (float *)&rx_velZ);
    //                                 // for (int i = 0; i < 51; i++)
    //                                 //     {
    //                                 //         buff[51] ^= buff[i];
    //                                 //     }
    //                                 //  #######################    Segunda Msg - Sat. Ephemerides - Variável    #########################


    //                                 double last_RX_time;
    //                                 // double longitude_deg;
    //                                 // double latitude_deg;
    //                                 // double height_m;
    //                                 // time_t UTC_time;
    //                                 double tempoo;
    //                                 double variavelTempo;
    //                                 double diffSATREC;
    //                                 double diffSATSAT = 1000;
    //                                 double delta_tempo;
    //                                 double nvotempo;
    //                                 double limiar = 0.2;

    //                                 double gps_time_offset;
    //                                 int index = 52;
    //                                 double deltaprange{0};

    //                                 // uint8_t msgVec[tam]{0};

    //                                 // Integer2Hexx(&msgVec[0],0xd4);
    //                                 buff[index] = 0xd4;
    //                                 // Double2Hexx(&buff[1], 70);
    //                                 uint8_t checks{0};
    //                                 for (const auto &y : gnss_synchro)
    //                                     {
    //                                         for (const auto &x : gps_map)
    //                                             {
    //                                                 if (y.second.System == 'G')
    //                                                     {
    //                                                         last_RX_time = y.second.TOW_at_current_symbol_ms;
    //                                                         if (y.second.PRN == x.second.PRN)
    //                                                             {
    //                                                                 tempoo = y.second.RX_time;
    //                                                                 std::vector<double> LastSatPos(3);
    //                                                                 // std::vector<double> LastSatVel(3);
    //                                                                 gps_map.at(x.first).satellitePosition(tempoo);
    //                                                                 // if ((pvt_ptr->get_latest_PVT_(&longitude_deg,
    //                                                                 //          &latitude_deg,
    //                                                                 //          &height_m,
    //                                                                 //          &UTC_time,
    //                                                                 //          &gps_time_offset,
    //                                                                 //          &rx_posX,
    //                                                                 //          &rx_posY,
    //                                                                 //          &rx_posZ,
    //                                                                 //          &rx_velX,
    //                                                                 //          &rx_velY,
    //                                                                 //          &rx_velZ) == true))
    //                                                                 //     {
    //                                                                 //  Step 1
    //                                                                 LastSatPos[0] = x.second.satpos_X;
    //                                                                 LastSatPos[1] = x.second.satpos_Y;
    //                                                                 LastSatPos[2] = x.second.satpos_Z;

    //                                                                 while (diffSATSAT > limiar)
    //                                                                     {
    //                                                                         //  Step 2
    //                                                                         diffSATREC = sqrt(
    //                                                                             (rx_posX - LastSatPos[0]) * (rx_posX - LastSatPos[0]) +
    //                                                                             (rx_posY - LastSatPos[1]) * (rx_posY - LastSatPos[1]) +
    //                                                                             (rx_posZ - LastSatPos[2]) * (rx_posZ - LastSatPos[2]));
    //                                                                         delta_tempo = diffSATREC / SPEED_OF_LIGHT_M_S;
    //                                                                         // Step 3
    //                                                                         nvotempo = tempoo - delta_tempo;
    //                                                                         gps_map.at(x.first).satellitePosition(nvotempo);
    //                                                                         diffSATSAT = sqrt(
    //                                                                             (LastSatPos[0] - x.second.satpos_X) * (LastSatPos[0] - x.second.satpos_X) +
    //                                                                             (LastSatPos[1] - x.second.satpos_Y) * (LastSatPos[1] - x.second.satpos_Y) +
    //                                                                             (LastSatPos[2] - x.second.satpos_Z) * (LastSatPos[2] - x.second.satpos_Z));
    //                                                                         LastSatPos[0] = x.second.satpos_X;
    //                                                                         LastSatPos[1] = x.second.satpos_Y;
    //                                                                         LastSatPos[2] = x.second.satpos_Z;
    //                                                                     }
    //                                                                 // Step 4
    //                                                                 variavelTempo = nvotempo - gps_time_offset;
    //                                                                 gps_map.at(x.first).satellitePosition(variavelTempo);
    //                                                                 // }
    //                                                                 double prange = sqrt(
    //                                                                     (LastSatPos[0] - rx_posX) * (LastSatPos[0] - rx_posX) +
    //                                                                     (LastSatPos[1] - rx_posY) * (LastSatPos[1] - rx_posY) +
    //                                                                     (LastSatPos[2] - rx_posZ) * (LastSatPos[2] - rx_posZ));
    //                                                                 deltaprange = -SPEED_OF_LIGHT_M_S * (y.second.Carrier_Doppler_hz / 1575420000);
    //                                                                 satPosX = x.second.satpos_X;
    //                                                                 satPosY = x.second.satpos_Y;
    //                                                                 satPosZ = x.second.satpos_Z;
    //                                                                 satVelX = x.second.satvel_X;
    //                                                                 satVelY = x.second.satvel_Y;
    //                                                                 satVelZ = x.second.satvel_Z;
    //                                                                 // Integer2Hex(&msgVec[index + 1], &x.second.PRN);
    //                                                                 // buff[index + 1] = (uint8_t)y.second.PRN;
    //                                                                 // Double2Hex(&buff[index + 2], &y.second.Pseudorange_m);
    //                                                                 // Double2Hex(&buff[index + 10], &deltaprange);
    //                                                                 // Double2Hex(&buff[index + 18], &x.second.satpos_X);
    //                                                                 // Double2Hex(&buff[index + 26], &x.second.satpos_Y);
    //                                                                 // Double2Hex(&buff[index + 34], &x.second.satpos_Z);
    //                                                                 // Double2Hex(&buff[index + 42], &x.second.satvel_X);
    //                                                                 // Double2Hex(&buff[index + 50], &x.second.satvel_Y);
    //                                                                 // Double2Hex(&buff[index + 58], &x.second.satvel_Z);
    //                                                                 // index = index + 65;
    //                                                                 arqtest
    //                                                                     // // std::cout
    //                                                                     << " "
    //                                                                     << x.second.PRN
    //                                                                     << " "
    //                                                                     << prange
    //                                                                     << " "
    //                                                                     << deltaprange
    //                                                                     << " "
    //                                                                     << satPosX
    //                                                                     << " "
    //                                                                     << satPosY
    //                                                                     << " "
    //                                                                     << satPosZ
    //                                                                     << " "
    //                                                                     << satVelX
    //                                                                     << " "
    //                                                                     << satVelY
    //                                                                     << " "
    //                                                                     << satVelZ;
    //                                                             }
    //                                                     }
    //                                             }
    //                                     }
    //                                 // // std::cout<<"\n";
    //                                 arqtest << "\n";
    //                                 arqtestPVT
    //                                 // // std::cout
    //                                 << " "
    //                                 << last_RX_time << "\n";
    //                                 // for (int i = 0; i < index + 1; i++)
    //                                 //     {
    //                                 //         // msgVec[index + 1] = msgVec[index + 1] ^ msgVec[i];  // CRC
    //                                 //         checks ^= buff[i];
    //                                 //     }
    //                                 // buff[index + 1] = checks;
    //                                 // int bytes = HEserial_envio(&comms, &msgVec[0], &tam);
    //                                 // // std::cout << "Bytes: " << bytes << "\n";

    //                                 // // ##############################################################################################
    //                                 // //      Correto
    //                                 // // ##############################################################################################
    //                                 //                 // serial_sat_send(&rx_posX,
    //                                 //                 //  &rx_posY,
    //                                 //                 //  &rx_posZ,
    //                                 //                 //  &rx_velX,
    //                                 //                 //  &rx_velY,
    //                                 //                 //  &rx_velZ);

    //                                 //                 // tcflush(comms.fd, TCIFLUSH);

    //                                 //                 // uint8_t buff[msgSize]{0};
    //                                 //                 // UTC_time;
    //                                 //                 buff[0] = 0xd5;                                    // ,
    //                                 //                 Double2Hex(&buff[1], (double *)&tempo_ligado_ms);  // tem que ser em double
    //                                 //                 //
    //                                 //                 // Float2Hexx(&buff[9], 0x0000);   // modo
    //                                 //                 // Float2Hexx(&buff[17], 0x0000);  // Estado
    //                                 //                 //
    //                                 //                 buff[9] = 0x00; buff[10] = 0x00;
    //                                 //                 Float2Hex(&buff[11], (float *)&gdop);  // Colocar os dops como float
    //                                 //                 Float2Hex(&buff[15], (float *)&hdop);
    //                                 //                 Float2Hex(&buff[19], (float *)&vdop);
    //                                 //                 Float2Hex(&buff[23], (float *)&pdop);
    //                                 //                 Float2Hex(&buff[27], (float *)&rx_posX);
    //                                 //                 Float2Hex(&buff[31], (float *)&rx_posY);
    //                                 //                 Float2Hex(&buff[35], (float *)&rx_posZ);
    //                                 //                 Float2Hex(&buff[39], (float *)&rx_velX);
    //                                 //                 Float2Hex(&buff[43], (float *)&rx_velY);
    //                                 //                 Float2Hex(&buff[47], (float *)&rx_velZ);
    //                                 //                 for (int i = 0; i < 51; i++)
    //                                 //                     {
    //                                 //                         buff[51] ^= buff[i];
    //                                 //                     }
    //                                 // ##########################################################################################
    //                                 // bytes = HEserial_envio(&comms, &buff[0], &msgSize); //tcflush(comms.fd, TCIFLUSH);
    //                                 // msgSize = 16;
    //                                 // uint8_t test[] = {0xFF,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x3E,0x80};


    //                                 // tcdrain(comms.fd);
    //                                 // tcflush(comms.fd, TCIOFLUSH);
    //                                 // bytes = HEserial_envio(&comms, &test, &msgSize); contador++;
    //                                 // bytes = write(comms.fd, &test, msgSize);
    //                                 // bytes = write(comms.fd, &buff[0], msgSize);
    //                                 // contador++;  // tcdrain(comms.fd);
    //                                 // tcflush(comms.fd, TCIOFLUSH);
    //                                 // // std::cout << TEXT_BOLD_CYAN
    //                                 //           << "PVT_msg: " << bytes
    //                                 //           << " " << contador
    //                                 //         //   << " " << (int)buff[msgSize - 1]
    //                                 //           << TEXT_RESET << "\n";
    //                             }
    //                         //                                 else{
    //                         //                                     uint8_t buff[msgSize];
    //                         //                                     for(int i = 0; i<66;i++)
    //                         //                                     {
    //                         //                                         buff[i] = 0xFF;
    //                         //                                     }
    //                         //                                     buff[0]=0xd4;
    //                         //                                     Double2Hex(&buff[1], &tempo_ligado_ms);
    //                         //                                     buff[10] = (uint8_t)num_sat;
    //                         //                                 }
    //                         //                         // }
    //                     }
    //             }
    //     }
    // arqtest.close();
    // arqtestPVT.close();
}

void ControlThread::serial_sat_send(double *rx_posX, double *rx_posY, double *rx_posZ, double *rx_velX, double *rx_velY, double *rx_velZ)
{
    // std::shared_ptr<PvtInterface> pvt_ptr = flowgraph_->get_pvt();
    // std::map<int, Gps_Ephemeris> gps_map = pvt_ptr->get_gps_ephemeris();
    // std::map<int, Gnss_Synchro> gnss_synchro = pvt_ptr->get_gnss_observables();

    // double last_RX_time;
    // // double longitude_deg;
    // // double latitude_deg;
    // // double height_m;
    // // time_t UTC_time;
    // double tempoo;
    // double variavelTempo;
    // double diffSATREC;
    // double diffSATSAT = 1000;
    // double delta_tempo;
    // double nvotempo;
    // double limiar = 0.2;
    
    // double gps_time_offset;
    // int index = 0;
    // double deltaprange{0};
    // int num_sat = pvt_ptr->get_num_sat_observ();
    // int tam = num_sat * 65 + 2;
    // uint8_t msgVec[tam]{0};
    // // tcflush(comms.fd, TCIFLUSH);
    // // Integer2Hexx(&msgVec[0],0xd4);
    // msgVec[0] = 0xd4;
    // Double2Hexx(&msgVec[1],70);
    // uint8_t checks{0};
    // for (const auto &y : gnss_synchro)
    //     {
    //         for (const auto &x : gps_map)
    //             {
    //                 if (y.second.System == 'G')
    //                     {
    //                         last_RX_time = y.second.RX_time;
    //                         if (y.second.PRN == x.second.PRN)
    //                             {
    //                                 tempoo = y.second.RX_time;
    //                                 std::vector<double> LastSatPos(3);
    //                                 gps_map.at(x.first).satellitePosition(tempoo);
    //                                 // if ((pvt_ptr->get_latest_PVT_(&longitude_deg,
    //                                 //          &latitude_deg,
    //                                 //          &height_m,
    //                                 //          &UTC_time,
    //                                 //          &gps_time_offset,
    //                                 //          &rx_posX,
    //                                 //          &rx_posY,
    //                                 //          &rx_posZ,
    //                                 //          &rx_velX,
    //                                 //          &rx_velY,
    //                                 //          &rx_velZ) == true))
    //                                 //     {
    //                                         //  Step 1
    //                                         LastSatPos[0] = x.second.satpos_X;
    //                                         LastSatPos[1] = x.second.satpos_Y;
    //                                         LastSatPos[2] = x.second.satpos_Z;

    //                                         while (diffSATSAT > limiar)
    //                                             {
    //                                                 //  Step 2
    //                                                 diffSATREC = sqrt(
    //                                                     (*rx_posX - LastSatPos[0]) * (*rx_posX - LastSatPos[0]) +
    //                                                     (*rx_posY - LastSatPos[1]) * (*rx_posY - LastSatPos[1]) +
    //                                                     (*rx_posZ - LastSatPos[2]) * (*rx_posZ - LastSatPos[2]));
    //                                                 delta_tempo = diffSATREC / SPEED_OF_LIGHT_M_S;
    //                                                 // Step 3
    //                                                 nvotempo = tempoo - delta_tempo;
    //                                                 gps_map.at(x.first).satellitePosition(nvotempo);
    //                                                 diffSATSAT = sqrt(
    //                                                     (LastSatPos[0] - x.second.satpos_X) * (LastSatPos[0] - x.second.satpos_X) +
    //                                                     (LastSatPos[1] - x.second.satpos_Y) * (LastSatPos[1] - x.second.satpos_Y) +
    //                                                     (LastSatPos[2] - x.second.satpos_Z) * (LastSatPos[2] - x.second.satpos_Z));
    //                                                 LastSatPos[0] = x.second.satpos_X;
    //                                                 LastSatPos[1] = x.second.satpos_Y;
    //                                                 LastSatPos[2] = x.second.satpos_Z;
    //                                             }
    //                                         // Step 4
    //                                         variavelTempo = nvotempo - gps_time_offset;
    //                                         gps_map.at(x.first).satellitePosition(variavelTempo);
    //                                     // }
    //                                 deltaprange = -SPEED_OF_LIGHT_M_S * (y.second.Carrier_Doppler_hz / 1575420000);
    //                                 // Integer2Hex(&msgVec[index + 1], &x.second.PRN);
    //                                 msgVec[index + 1] = (uint8_t)y.second.PRN;
    //                                 Double2Hex(&msgVec[index + 2], &y.second.Pseudorange_m);
    //                                 Double2Hex(&msgVec[index + 10], &deltaprange);
    //                                 Double2Hex(&msgVec[index + 18], &x.second.satpos_X);
    //                                 Double2Hex(&msgVec[index + 26], &x.second.satpos_Y);
    //                                 Double2Hex(&msgVec[index + 34], &x.second.satpos_Z);
    //                                 Double2Hex(&msgVec[index + 42], &x.second.satvel_X);
    //                                 Double2Hex(&msgVec[index + 50], &x.second.satvel_Y);
    //                                 Double2Hex(&msgVec[index + 58], &x.second.satvel_Z);
    //                                 index = index + 65;

    //                             }
    //                     }
    //             }
    //     }
    // for (int i = 0; i < index+1; i++)
    //     {
    //         // msgVec[index + 1] = msgVec[index + 1] ^ msgVec[i];  // CRC
    //         checks ^= msgVec[i];
    //     }
    //     msgVec[261]=checks;
    // int bytes = HEserial_envio(&comms, &msgVec[0], &tam);
    // // std::cout<<"Bytes: "<<bytes<<"\n";
    // // 
}


// void ControlThread::serialcmd_printer(void)
// {
    // std::shared_ptr<PvtInterface> pvt_ptr = flowgraph_->get_pvt();
    // while (serialcmd_enabled_)
    //     {
    //         double longitude_deg;
    //         double latitude_deg;
    //         double height_m;
    //         time_t UTC_time;
    //         double gdop, hdop, vdop, pdop;
    //         int bytes;
    //         int msgSize = 59;
    //         tcflush(comms.fd, TCIFLUSH);
    //         if ((pvt_ptr->get_latest_PVT_2(
    //                  &longitude_deg,
    //                  &latitude_deg,
    //                  &height_m,
    //                  &UTC_time,
    //                  &gdop,
    //                  &hdop,
    //                  &vdop,
    //                  &pdop) == true))
    //             {
    //                 uint8_t buff[msgSize];
    //                 // UTC_time;
    //                 buff[0] = 0x02;  // 0x02,
    //                 buff[1] = 0x00;  // 0x00,
    //                 Double2Hex(&buff[2], &gdop);
    //                 Double2Hex(&buff[10], &hdop);
    //                 Double2Hex(&buff[18], &vdop);
    //                 Double2Hex(&buff[26], &pdop);
    //                 Double2Hex(&buff[34], &latitude_deg);
    //                 Double2Hex(&buff[42], &longitude_deg);
    //                 Double2Hex(&buff[50], &height_m);
    //                 buff[58] = 0xFF;
    //                 bytes = HEserial_envio(&comms, &buff[0], &msgSize);
    //                 // bytes = serial4send(&buff[0], &msgSize);
    //             }
    //     }
// }

void ControlThread::event_dispatcher(bool &valid_event, pmt::pmt_t &msg)
{
    if (valid_event)
        {
            processed_control_messages_++;
            const size_t msg_type_hash_code = pmt::any_ref(msg).type().hash_code();
            if (msg_type_hash_code == channel_event_type_hash_code_)
                {
                    if (receiver_on_standby_ == false)
                        {
                            const auto new_event = wht::any_cast<channel_event_sptr>(pmt::any_ref(msg));
                            // DLOG(INFO) << "New channel event rx from ch id: " << new_event->channel_id
                                    //    << " what: " << new_event->event_type;
                            flowgraph_->apply_action(new_event->channel_id, new_event->event_type);
                        }
                }
            else if (msg_type_hash_code == command_event_type_hash_code_)
                {
                    const auto new_event = wht::any_cast<command_event_sptr>(pmt::any_ref(msg));
                    // DLOG(INFO) << "New command event rx from ch id: " << new_event->command_id
                            //    << " what: " << new_event->event_type;

                    if (new_event->command_id == 200)
                        {
                            apply_action(new_event->event_type);
                        }
                    else
                        {
                            if (new_event->command_id == 300)  // some TC commands require also actions from control_thread
                                {
                                    apply_action(new_event->event_type);
                                }
                            flowgraph_->apply_action(new_event->command_id, new_event->event_type);
                        }
                }
            else
                {
                    // DLOG(INFO) << "Control Queue: unknown object type!\n";
                }
        }
    else
        {
            if (receiver_on_standby_ == false)
                {
                    // perform non-priority tasks
                    flowgraph_->acquisition_manager(0);  // start acquisition of untracked satellites
                }
        }
}


/*
 * Runs the control thread that manages the receiver control plane
 *
 * This is the main loop that reads and process the control messages
 * 1- Connect the GNSS receiver flowgraph
 * 2- Start the GNSS receiver flowgraph
 *    while (flowgraph_->running() && !stop)_{
 * 3- Read control messages and process them }
 */
int ControlThread::run()
{
    auto tStartSteady = std::chrono::steady_clock::now();
    // Connect the flowgraph
    if (!flowgraph_)
        {
            print_help_at_exit();
            return 0;
        }
    try
        {
            flowgraph_->connect();
        }
    catch (const std::exception &e)
        {
            // LOG(ERROR) << e.what();
            return 0;
        }
    if (flowgraph_->connected())
        {
           // LOG(INFO) << "Flowgraph connected";
        }
    else
        {
            return 0;
        }
    // Start the flowgraph
    flowgraph_->start();
    if (flowgraph_->running())
        {
           // LOG(INFO) << "Flowgraph started";
        }
    else
        {
            return 0;
        }

    // launch GNSS assistance process AFTER the flowgraph is running because the GNU Radio asynchronous queues must be already running to transport msgs
    assist_GNSS();
    // start the keyboard_listener thread
    // if (FLAGS_keyboard)
    //     {
    //         keyboard_thread_ = std::thread(&ControlThread::keyboard_listener, this);
    //     }
    // sysv_queue_thread_ = std::thread(&ControlThread::sysv_queue_listener, this);

    // start the telecommand listener thread
    cmd_interface_.set_pvt(flowgraph_->get_pvt());
    cmd_interface_thread_ = std::thread(&ControlThread::telecommand_listener, this);

    // Caio
    // Fazer um listener thread para Serial Cmd
    // std::cout << TEXT_BOLD_BLUE << "Caio: Listener Thread Serial Cmd" << TEXT_RESET << "\n";
    serial_cmd_interface_.set_pvt(flowgraph_->get_pvt());
    serial_cmd_interface_.set_Acq(flowgraph_->get_Acq());
    serial_cmd_interface_.set_Trk(flowgraph_->get_Trk());
    // serial_cmd_interface_.set_Sync(flowgraph_->get_SerialSync());
    serial_cmd_interface_.set_channels(flowgraph_->get_channels());

    // Thread Serial Listener
    // serial_cmd_interface_thread_ = std::thread(&ControlThread::serialcmd_listener, this);
    PPS_siggen_thread_=std::thread(&ControlThread::PPS_GPIO_ctrl,this);
    // sched_param sch_params;
    // int policy;
    // pthread_getschedparam(PPS_siggen_thread_.native_handle(), &policy, &sch_params);
    // sch_params.sched_priority = 97;
    // if (pthread_setschedparam(PPS_siggen_thread_.native_handle(), SCHED_FIFO, &sch_params))
    //     std::cout << "Failed to PPS_SigGen setschedparam: " << std::strerror(errno) << '\n';
    
    // serial_cmd_interface_thread_w = std::thread(&ControlThread::serialcmd_printer, this);
    // Cria uma thread para isso, mas é necessário fechar com .join()
    // na função dos destructors

    // Caio - timers
    // serial_timer_function_thread_ = std::thread(&ControlThread::serialcmd_timer, this);

#ifdef ENABLE_FPGA
    // Create a task for the acquisition such that id doesn't block the flow of the control thread
    fpga_helper_thread_ = boost::thread(&GNSSFlowgraph::start_acquisition_helper,
        flowgraph_);
#endif
    // Main loop to read and process the control messages
    pmt::pmt_t msg;
    while (flowgraph_->running() && !stop_)
        {
            // read event messages, triggered by event signaling with a 100 ms timeout to perform low priority receiver management tasks
            bool valid_event = control_queue_->timed_wait_and_pop(msg, 100);
            // call the new sat dispatcher and receiver controller
            event_dispatcher(valid_event, msg);
        }
    // std::cout << "Stopping GNSS-SDR, please wait!\n";
    flowgraph_->stop();
    stop_ = true;
    flowgraph_->disconnect();

#ifdef ENABLE_FPGA
    // trigger a HW reset
    // The HW reset causes any HW accelerator module that is waiting for more samples to complete its calculations
    // to trigger an interrupt and finish its signal processing tasks immediately. In this way all SW threads that
    // are waiting for interrupts in the HW can exit in a normal way.
    flowgraph_->perform_hw_reset();
    fpga_helper_thread_.try_join_until(boost::chrono::steady_clock::now() + boost::chrono::milliseconds(1000));
#endif

    // Terminate keyboard thread
//     if (FLAGS_keyboard && keyboard_thread_.joinable())
//         {
//             pthread_t id = keyboard_thread_.native_handle();
//             keyboard_thread_.detach();
// #ifndef ANDROID
//             pthread_cancel(id);
// #else
//             // todo: find alternative
// #endif
//         }

    // Terminate telecommand thread
//     if (telecommand_enabled_)
//         {
//             pthread_t id2 = cmd_interface_thread_.native_handle();
//             cmd_interface_thread_.detach();
// #ifndef ANDROID
//             pthread_cancel(id2);
// #else
//             // todo: find alternative
// #endif
//         }

    // Caio
    //  A thread precisa ser finalizada
    if (serialcmd_enabled_)
        {
            // std::cout << "Caio: Finalizada a Serial Thread" << "\n";
            // pthread_t id3 = serial_cmd_interface_thread_.native_handle();
            // serial_cmd_interface_thread_.detach();
            // pthread_cancel(id3);

            // std::cout << "Caio: Finalizada a Serial Timer Thread" << "\n";
            // pthread_t id4 = serial_timer_function_thread_.native_handle();
            // serial_timer_function_thread_.detach();
            // pthread_cancel(id4);

            // pthread_t id5 = serial_cmd_interface_thread_w.native_handle();
            // serial_cmd_interface_thread_w.detach();
            // pthread_cancel(id5);

            pthread_t id8 = PPS_siggen_thread_.native_handle();
            PPS_siggen_thread_.detach();
            pthread_cancel(id8);
        }

   // LOG(INFO) << "Flowgraph stopped";

    if (restart_)
        {
            return 42;  // signal the gnss-sdr-harness.sh to restart the receiver program
        }

    return 0;  // normal shutdown
}


void ControlThread::set_control_queue(std::shared_ptr<Concurrent_Queue<pmt::pmt_t>> control_queue)
{
    if (flowgraph_->running())
        {
            // LOG(WARNING) << "Unable to set control queue while flowgraph is running";
            return;
        }
    control_queue_ = std::move(control_queue);
    cmd_interface_.set_msg_queue(control_queue_);

    // Caio
    // std::cout << "Caio: set_control_queue" << "\n";
    serial_control_queue_ = std::move(control_queue);
    serial_cmd_interface_.set_msg_queue(serial_control_queue_);
}


/*
 * Returns true if reading was successful
 */
bool ControlThread::read_assistance_from_XML()
{
    // return variable (true == succeeded)
    bool ret = false;
    // getting names from the config file, if available
    std::string eph_xml_filename = configuration_->property("GNSS-SDR.SUPL_gps_ephemeris_xml", eph_default_xml_filename_);
    std::string utc_xml_filename = configuration_->property("GNSS-SDR.SUPL_gps_utc_model_xml", utc_default_xml_filename_);
    std::string iono_xml_filename = configuration_->property("GNSS-SDR.SUPL_gps_iono_xml", iono_default_xml_filename_);
    std::string gal_iono_xml_filename = configuration_->property("GNSS-SDR.SUPL_gal_iono_xml", gal_iono_default_xml_filename_);
    std::string ref_time_xml_filename = configuration_->property("GNSS-SDR.SUPL_gps_ref_time_xml", ref_time_default_xml_filename_);
    std::string ref_location_xml_filename = configuration_->property("GNSS-SDR.SUPL_gps_ref_location_xml", ref_location_default_xml_filename_);
    std::string eph_gal_xml_filename = configuration_->property("GNSS-SDR.SUPL_gal_ephemeris_xml", eph_gal_default_xml_filename_);
    std::string eph_cnav_xml_filename = configuration_->property("GNSS-SDR.SUPL_gps_cnav_ephemeris_xml", eph_cnav_default_xml_filename_);
    std::string gal_utc_xml_filename = configuration_->property("GNSS-SDR.SUPL_gal_utc_model_xml", gal_utc_default_xml_filename_);
    std::string cnav_utc_xml_filename = configuration_->property("GNSS-SDR.SUPL_cnav_utc_model_xml", cnav_utc_default_xml_filename_);
    std::string eph_glo_xml_filename = configuration_->property("GNSS-SDR.SUPL_glo_ephemeris_xml", eph_glo_gnav_default_xml_filename_);
    std::string glo_utc_xml_filename = configuration_->property("GNSS-SDR.SUPL_glo_utc_model_xml", glo_utc_default_xml_filename_);
    std::string gal_almanac_xml_filename = configuration_->property("GNSS-SDR.SUPL_gal_almanac_xml", gal_almanac_default_xml_filename_);
    std::string gps_almanac_xml_filename = configuration_->property("GNSS-SDR.SUPL_gps_almanac_xml", gps_almanac_default_xml_filename_);

    if (configuration_->property("GNSS-SDR.AGNSS_XML_enabled", false) == true)
        {
            eph_xml_filename = configuration_->property("GNSS-SDR.AGNSS_gps_ephemeris_xml", eph_default_xml_filename_);
            utc_xml_filename = configuration_->property("GNSS-SDR.AGNSS_gps_utc_model_xml", utc_default_xml_filename_);
            iono_xml_filename = configuration_->property("GNSS-SDR.AGNSS_gps_iono_xml", iono_default_xml_filename_);
            gal_iono_xml_filename = configuration_->property("GNSS-SDR.AGNSS_gal_iono_xml", gal_iono_default_xml_filename_);
            ref_time_xml_filename = configuration_->property("GNSS-SDR.AGNSS_gps_ref_time_xml", ref_time_default_xml_filename_);
            ref_location_xml_filename = configuration_->property("GNSS-SDR.AGNSS_gps_ref_location_xml", ref_location_default_xml_filename_);
            eph_gal_xml_filename = configuration_->property("GNSS-SDR.AGNSS_gal_ephemeris_xml", eph_gal_default_xml_filename_);
            eph_cnav_xml_filename = configuration_->property("GNSS-SDR.AGNSS_gps_cnav_ephemeris_xml", eph_cnav_default_xml_filename_);
            gal_utc_xml_filename = configuration_->property("GNSS-SDR.AGNSS_gal_utc_model_xml", gal_utc_default_xml_filename_);
            cnav_utc_xml_filename = configuration_->property("GNSS-SDR.AGNSS_cnav_utc_model_xml", cnav_utc_default_xml_filename_);
            eph_glo_xml_filename = configuration_->property("GNSS-SDR.AGNSS_glo_ephemeris_xml", eph_glo_gnav_default_xml_filename_);
            glo_utc_xml_filename = configuration_->property("GNSS-SDR.AGNSS_glo_utc_model_xml", glo_utc_default_xml_filename_);
            gal_almanac_xml_filename = configuration_->property("GNSS-SDR.AGNSS_gal_almanac_xml", gal_almanac_default_xml_filename_);
            gps_almanac_xml_filename = configuration_->property("GNSS-SDR.AGNSS_gps_almanac_xml", gps_almanac_default_xml_filename_);
        }

    // std::cout << "Trying to read GNSS ephemeris from XML file(s)...\n";

    if (configuration_->property("Channels_1C.count", 0) > 0)
        {
            if (supl_client_ephemeris_.load_ephemeris_xml(eph_xml_filename) == true)
                {
                    std::map<int, Gps_Ephemeris>::const_iterator gps_eph_iter;
                    for (gps_eph_iter = supl_client_ephemeris_.gps_ephemeris_map.cbegin();
                         gps_eph_iter != supl_client_ephemeris_.gps_ephemeris_map.cend();
                         gps_eph_iter++)
                        {
                            // std::cout << "From XML file: Read NAV ephemeris for satellite " << Gnss_Satellite("GPS", gps_eph_iter->second.PRN) << '\n';
                            const std::shared_ptr<Gps_Ephemeris> tmp_obj = std::make_shared<Gps_Ephemeris>(gps_eph_iter->second);
                            flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                        }
                    ret = true;
                }

            if (supl_client_acquisition_.load_utc_xml(utc_xml_filename) == true)
                {
                    const std::shared_ptr<Gps_Utc_Model> tmp_obj = std::make_shared<Gps_Utc_Model>(supl_client_acquisition_.gps_utc);
                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                    // std::cout << "From XML file: Read GPS UTC model parameters.\n";
                    ret = true;
                }

            if (supl_client_acquisition_.load_iono_xml(iono_xml_filename) == true)
                {
                    const std::shared_ptr<Gps_Iono> tmp_obj = std::make_shared<Gps_Iono>(supl_client_acquisition_.gps_iono);
                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                    // std::cout << "From XML file: Read GPS ionosphere model parameters.\n";
                    ret = true;
                }

            if (supl_client_ephemeris_.load_gps_almanac_xml(gps_almanac_xml_filename) == true)
                {
                    std::map<int, Gps_Almanac>::const_iterator gps_alm_iter;
                    for (gps_alm_iter = supl_client_ephemeris_.gps_almanac_map.cbegin();
                         gps_alm_iter != supl_client_ephemeris_.gps_almanac_map.cend();
                         gps_alm_iter++)
                        {
                            // std::cout << "From XML file: Read GPS almanac for satellite " << Gnss_Satellite("GPS", gps_alm_iter->second.PRN) << '\n';
                            const std::shared_ptr<Gps_Almanac> tmp_obj = std::make_shared<Gps_Almanac>(gps_alm_iter->second);
                            flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                        }
                    ret = true;
                }
        }

    if ((configuration_->property("Channels_1B.count", 0) > 0) || (configuration_->property("Channels_5X.count", 0) > 0) ||
        (configuration_->property("Channels_7X.count", 0) > 0) || (configuration_->property("Channels_E6.count", 0) > 0))
        {
            if (supl_client_ephemeris_.load_gal_ephemeris_xml(eph_gal_xml_filename) == true)
                {
                    std::map<int, Galileo_Ephemeris>::const_iterator gal_eph_iter;
                    for (gal_eph_iter = supl_client_ephemeris_.gal_ephemeris_map.cbegin();
                         gal_eph_iter != supl_client_ephemeris_.gal_ephemeris_map.cend();
                         gal_eph_iter++)
                        {
                            // std::cout << "From XML file: Read ephemeris for satellite " << Gnss_Satellite("Galileo", gal_eph_iter->second.PRN) << '\n';
                            const std::shared_ptr<Galileo_Ephemeris> tmp_obj = std::make_shared<Galileo_Ephemeris>(gal_eph_iter->second);
                            flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                        }
                    ret = true;
                }

            if (supl_client_acquisition_.load_gal_iono_xml(gal_iono_xml_filename) == true)
                {
                    const std::shared_ptr<Galileo_Iono> tmp_obj = std::make_shared<Galileo_Iono>(supl_client_acquisition_.gal_iono);
                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                    // std::cout << "From XML file: Read Galileo ionosphere model parameters.\n";
                    ret = true;
                }

            if (supl_client_acquisition_.load_gal_utc_xml(gal_utc_xml_filename) == true)
                {
                    const std::shared_ptr<Galileo_Utc_Model> tmp_obj = std::make_shared<Galileo_Utc_Model>(supl_client_acquisition_.gal_utc);
                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                    // std::cout << "From XML file: Read Galileo UTC model parameters.\n";
                    ret = true;
                }

            if (supl_client_ephemeris_.load_gal_almanac_xml(gal_almanac_xml_filename) == true)
                {
                    std::map<int, Galileo_Almanac>::const_iterator gal_alm_iter;
                    for (gal_alm_iter = supl_client_ephemeris_.gal_almanac_map.cbegin();
                         gal_alm_iter != supl_client_ephemeris_.gal_almanac_map.cend();
                         gal_alm_iter++)
                        {
                            // std::cout << "From XML file: Read Galileo almanac for satellite " << Gnss_Satellite("Galileo", gal_alm_iter->second.PRN) << '\n';
                            const std::shared_ptr<Galileo_Almanac> tmp_obj = std::make_shared<Galileo_Almanac>(gal_alm_iter->second);
                            flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                        }
                    ret = true;
                }
        }

    if ((configuration_->property("Channels_2S.count", 0) > 0) || (configuration_->property("Channels_L5.count", 0) > 0))
        {
            if (supl_client_ephemeris_.load_cnav_ephemeris_xml(eph_cnav_xml_filename) == true)
                {
                    std::map<int, Gps_CNAV_Ephemeris>::const_iterator gps_cnav_eph_iter;
                    for (gps_cnav_eph_iter = supl_client_ephemeris_.gps_cnav_ephemeris_map.cbegin();
                         gps_cnav_eph_iter != supl_client_ephemeris_.gps_cnav_ephemeris_map.cend();
                         gps_cnav_eph_iter++)
                        {
                            // std::cout << "From XML file: Read CNAV ephemeris for satellite " << Gnss_Satellite("GPS", gps_cnav_eph_iter->second.PRN) << '\n';
                            const std::shared_ptr<Gps_CNAV_Ephemeris> tmp_obj = std::make_shared<Gps_CNAV_Ephemeris>(gps_cnav_eph_iter->second);
                            flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                        }
                    ret = true;
                }

            if (supl_client_acquisition_.load_cnav_utc_xml(cnav_utc_xml_filename) == true)
                {
                    const std::shared_ptr<Gps_CNAV_Utc_Model> tmp_obj = std::make_shared<Gps_CNAV_Utc_Model>(supl_client_acquisition_.gps_cnav_utc);
                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                    // std::cout << "From XML file: Read GPS CNAV UTC model parameters.\n";
                    ret = true;
                }
        }

    if ((configuration_->property("Channels_1G.count", 0) > 0) || (configuration_->property("Channels_2G.count", 0) > 0))
        {
            if (supl_client_ephemeris_.load_gnav_ephemeris_xml(eph_glo_xml_filename) == true)
                {
                    std::map<int, Glonass_Gnav_Ephemeris>::const_iterator glo_gnav_eph_iter;
                    for (glo_gnav_eph_iter = supl_client_ephemeris_.glonass_gnav_ephemeris_map.cbegin();
                         glo_gnav_eph_iter != supl_client_ephemeris_.glonass_gnav_ephemeris_map.cend();
                         glo_gnav_eph_iter++)
                        {
                            // std::cout << "From XML file: Read GLONASS GNAV ephemeris for satellite " << Gnss_Satellite("GLONASS", glo_gnav_eph_iter->second.PRN) << '\n';
                            const std::shared_ptr<Glonass_Gnav_Ephemeris> tmp_obj = std::make_shared<Glonass_Gnav_Ephemeris>(glo_gnav_eph_iter->second);
                            flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                        }
                    ret = true;
                }

            if (supl_client_acquisition_.load_glo_utc_xml(glo_utc_xml_filename) == true)
                {
                    const std::shared_ptr<Glonass_Gnav_Utc_Model> tmp_obj = std::make_shared<Glonass_Gnav_Utc_Model>(supl_client_acquisition_.glo_gnav_utc);
                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                    // std::cout << "From XML file: Read GLONASS UTC model parameters.\n";
                    ret = true;
                }
        }

    if (ret == false)
        {
            // std::cout << "Error reading XML files\n";
            // std::cout << "Disabling GNSS assistance...\n";
        }

    // Only look for {ref time, ref location} if SUPL is enabled
    const bool enable_gps_supl_assistance = configuration_->property("GNSS-SDR.SUPL_gps_enabled", false);
    if (enable_gps_supl_assistance == true)
        {
            // Try to read Ref Time from XML
            if (supl_client_acquisition_.load_ref_time_xml(ref_time_xml_filename) == true)
                {
                   // LOG(INFO) << "SUPL: Read XML Ref Time";
                    const std::shared_ptr<Agnss_Ref_Time> tmp_obj = std::make_shared<Agnss_Ref_Time>(supl_client_acquisition_.gps_time);
                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                }
            else
                {
                   // LOG(INFO) << "SUPL: could not read Ref Time XML";
                }

            // Try to read Ref Location from XML
            if (supl_client_acquisition_.load_ref_location_xml(ref_location_xml_filename) == true)
                {
                   // LOG(INFO) << "SUPL: Read XML Ref Location";
                    const std::shared_ptr<Agnss_Ref_Location> tmp_obj = std::make_shared<Agnss_Ref_Location>(supl_client_acquisition_.gps_ref_loc);
                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                }
            else
                {
                   // LOG(INFO) << "SUPL: could not read Ref Location XML";
                }
        }

    return ret;
}


void ControlThread::assist_GNSS()
{
    // ######### GNSS Assistance #################################
    // GNSS Assistance configuration
    const bool enable_gps_supl_assistance = configuration_->property("GNSS-SDR.SUPL_gps_enabled", false);
    const bool enable_agnss_xml = configuration_->property("GNSS-SDR.AGNSS_XML_enabled", false);
    if ((enable_gps_supl_assistance == true) && (enable_agnss_xml == false))
        {
            // std::cout << "SUPL RRLP GPS assistance enabled!\n";
            const std::string default_acq_server("supl.google.com");
            const std::string default_eph_server("supl.google.com");
            supl_client_ephemeris_.server_name = configuration_->property("GNSS-SDR.SUPL_gps_ephemeris_server", default_acq_server);
            supl_client_acquisition_.server_name = configuration_->property("GNSS-SDR.SUPL_gps_acquisition_server", default_eph_server);
            supl_client_ephemeris_.server_port = configuration_->property("GNSS-SDR.SUPL_gps_ephemeris_port", 7275);
            supl_client_acquisition_.server_port = configuration_->property("GNSS-SDR.SUPL_gps_acquisition_port", 7275);
            supl_mcc_ = configuration_->property("GNSS-SDR.SUPL_MCC", 244);
            supl_mns_ = configuration_->property("GNSS-SDR.SUPL_MNC ", 5);

            const std::string default_lac("0x59e2");
            const std::string default_ci("0x31b0");
            const std::string supl_lac_s = configuration_->property("GNSS-SDR.SUPL_LAC", default_lac);
            const std::string supl_ci_s = configuration_->property("GNSS-SDR.SUPL_CI", default_ci);
            try
                {
                    supl_lac_ = std::stoi(supl_lac_s, nullptr, 0);
                }
            catch (const std::invalid_argument &ia)
                {
                    std::cerr << "Invalid argument for SUPL LAC: " << ia.what() << '\n';
                    supl_lac_ = -1;
                }
            try
                {
                    supl_ci_ = std::stoi(supl_ci_s, nullptr, 0);
                }
            catch (const std::invalid_argument &ia)
                {
                    std::cerr << "Invalid argument for SUPL CI: " << ia.what() << '\n';
                    supl_ci_ = -1;
                }

            if (supl_lac_ < 0 || supl_lac_ > 65535)
                {
                    supl_lac_ = 0x59e2;
                }

            if (supl_ci_ < 0 || supl_ci_ > 268435455)  // 2^16 for GSM and CDMA, 2^28 for UMTS and LTE networks
                {
                    supl_ci_ = 0x31b0;
                }

            const bool SUPL_read_gps_assistance_xml = configuration_->property("GNSS-SDR.SUPL_read_gps_assistance_xml", false);
            if (SUPL_read_gps_assistance_xml == true)
                {
                    // Read assistance from file
                    if (read_assistance_from_XML())
                        {
                            // std::cout << "GNSS assistance data loaded from local XML file(s).\n";
                            // std::cout << "No SUPL request has been performed.\n";
                        }
                }
            else
                {
                    // Request ephemeris from SUPL server
                    supl_client_ephemeris_.request = 1;
                    // std::cout << "SUPL: Try to read GPS ephemeris data from SUPL server...\n";
                    int error = supl_client_ephemeris_.get_assistance(supl_mcc_, supl_mns_, supl_lac_, supl_ci_);
                    if (error == 0)
                        {
                            std::map<int, Gps_Ephemeris>::const_iterator gps_eph_iter;
                            for (gps_eph_iter = supl_client_ephemeris_.gps_ephemeris_map.cbegin();
                                 gps_eph_iter != supl_client_ephemeris_.gps_ephemeris_map.cend();
                                 gps_eph_iter++)
                                {
                                    // std::cout << "SUPL: Received ephemeris data for satellite " << Gnss_Satellite("GPS", gps_eph_iter->second.PRN) << '\n';
                                    const std::shared_ptr<Gps_Ephemeris> tmp_obj = std::make_shared<Gps_Ephemeris>(gps_eph_iter->second);
                                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                                }
                            // Save ephemeris to XML file
                            const std::string eph_xml_filename = configuration_->property("GNSS-SDR.SUPL_gps_ephemeris_xml", eph_default_xml_filename_);
                            if (supl_client_ephemeris_.save_ephemeris_map_xml(eph_xml_filename, supl_client_ephemeris_.gps_ephemeris_map) == true)
                                {
                                    // std::cout << "SUPL: XML ephemeris data file created\n";
                                }
                            else
                                {
                                    // std::cout << "SUPL: Failed to create XML ephemeris data file\n";
                                }
                        }
                    else
                        {
                            // std::cout << "ERROR: SUPL client request for ephemeris data returned " << error << '\n';
                            // std::cout << "Please check your network connectivity and SUPL server configuration\n";
                            // std::cout << "Trying to read AGNSS data from local XML file(s)...\n";
                            if (read_assistance_from_XML() == false)
                                {
                                    // std::cout << "ERROR: Could not read XML files: Disabling SUPL assistance.\n";
                                }
                        }

                    // Request almanac, IONO and UTC Model data
                    supl_client_ephemeris_.request = 0;
                    // std::cout << "SUPL: Try to read Almanac, Iono, Utc Model, Ref Time and Ref Location data from SUPL server...\n";
                    error = supl_client_ephemeris_.get_assistance(supl_mcc_, supl_mns_, supl_lac_, supl_ci_);
                    if (error == 0)
                        {
                            std::map<int, Gps_Almanac>::const_iterator gps_alm_iter;
                            for (gps_alm_iter = supl_client_ephemeris_.gps_almanac_map.cbegin();
                                 gps_alm_iter != supl_client_ephemeris_.gps_almanac_map.cend();
                                 gps_alm_iter++)
                                {
                                    // std::cout << "SUPL: Received almanac data for satellite " << Gnss_Satellite("GPS", gps_alm_iter->second.PRN) << '\n';
                                    const std::shared_ptr<Gps_Almanac> tmp_obj = std::make_shared<Gps_Almanac>(gps_alm_iter->second);
                                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                                }
                            supl_client_ephemeris_.save_gps_almanac_xml("gps_almanac_map.xml", supl_client_ephemeris_.gps_almanac_map);
                            if (supl_client_ephemeris_.gps_iono.valid == true)
                                {
                                    // std::cout << "SUPL: Received GPS Ionosphere model parameters\n";
                                    const std::shared_ptr<Gps_Iono> tmp_obj = std::make_shared<Gps_Iono>(supl_client_ephemeris_.gps_iono);
                                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                                }
                            if (supl_client_ephemeris_.gps_utc.valid == true)
                                {
                                    // std::cout << "SUPL: Received GPS UTC model parameters\n";
                                    const std::shared_ptr<Gps_Utc_Model> tmp_obj = std::make_shared<Gps_Utc_Model>(supl_client_ephemeris_.gps_utc);
                                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                                }
                            // Save iono and UTC model data to xml file
                            const std::string iono_xml_filename = configuration_->property("GNSS-SDR.SUPL_gps_iono_xml", iono_default_xml_filename_);
                            if (supl_client_ephemeris_.save_iono_xml(iono_xml_filename, supl_client_ephemeris_.gps_iono) == true)
                                {
                                    // std::cout << "SUPL: Iono data file created\n";
                                }
                            else
                                {
                                    // std::cout << "SUPL: Failed to create Iono data file\n";
                                }
                            const std::string utc_xml_filename = configuration_->property("GNSS-SDR.SUPL_gps_utc_model_xml", utc_default_xml_filename_);
                            if (supl_client_ephemeris_.save_utc_xml(utc_xml_filename, supl_client_ephemeris_.gps_utc) == true)
                                {
                                    // std::cout << "SUPL: UTC model data file created\n";
                                }
                            else
                                {
                                    // std::cout << "SUPL: Failed to create UTC model data file\n";
                                }
                        }
                    else
                        {
                            // std::cout << "ERROR: SUPL client for almanac data returned " << error << '\n';
                            // std::cout << "Please check your network connectivity and SUPL server configuration\n";
                        }

                    // Request acquisition assistance
                    supl_client_acquisition_.request = 2;
                    // std::cout << "SUPL: Try to read acquisition assistance data from SUPL server...\n";
                    error = supl_client_acquisition_.get_assistance(supl_mcc_, supl_mns_, supl_lac_, supl_ci_);
                    if (error == 0)
                        {
                            std::map<int, Gps_Acq_Assist>::const_iterator gps_acq_iter;
                            for (gps_acq_iter = supl_client_acquisition_.gps_acq_map.cbegin();
                                 gps_acq_iter != supl_client_acquisition_.gps_acq_map.cend();
                                 gps_acq_iter++)
                                {
                                    // std::cout << "SUPL: Received acquisition assistance data for satellite " << Gnss_Satellite("GPS", gps_acq_iter->second.PRN) << '\n';
                                    global_gps_acq_assist_map.write(gps_acq_iter->second.PRN, gps_acq_iter->second);
                                }
                            if (supl_client_acquisition_.gps_ref_loc.valid == true)
                                {
                                    // std::cout << "SUPL: Received Ref Location data (Acquisition Assistance)\n";
                                    agnss_ref_location_ = supl_client_acquisition_.gps_ref_loc;
                                    const std::shared_ptr<Agnss_Ref_Location> tmp_obj = std::make_shared<Agnss_Ref_Location>(agnss_ref_location_);
                                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                                    supl_client_acquisition_.save_ref_location_xml("agnss_ref_location.xml", agnss_ref_location_);
                                }
                            if (supl_client_acquisition_.gps_time.valid == true)
                                {
                                    // std::cout << "SUPL: Received Ref Time data (Acquisition Assistance)\n";
                                    agnss_ref_time_ = supl_client_acquisition_.gps_time;
                                    const std::shared_ptr<Agnss_Ref_Time> tmp_obj = std::make_shared<Agnss_Ref_Time>(agnss_ref_time_);
                                    flowgraph_->send_telemetry_msg(pmt::make_any(tmp_obj));
                                    supl_client_acquisition_.save_ref_time_xml("agnss_ref_time.xml", agnss_ref_time_);
                                }
                        }
                    else
                        {
                            // std::cout << "ERROR: SUPL client for acquisition assistance returned " << error << '\n';
                            // std::cout << "Please check your network connectivity and SUPL server configuration\n";
                            // std::cout << "Disabling SUPL acquisition assistance.\n";
                        }
                }
        }

    if ((enable_gps_supl_assistance == false) && (enable_agnss_xml == true))
        {
            // read assistance from file
            if (read_assistance_from_XML())
                {
                    // std::cout << "GNSS assistance data loaded from local XML file(s).\n";
                }
        }

    // If AGNSS is enabled, make use of it
    if ((agnss_ref_location_.valid == true) && ((enable_gps_supl_assistance == true) || (enable_agnss_xml == true)))
        {
            // Get the list of visible satellites
            std::array<float, 3> ref_LLH{};
            ref_LLH[0] = agnss_ref_location_.lat;
            ref_LLH[1] = agnss_ref_location_.lon;
            time_t ref_rx_utc_time = 0;
            if (agnss_ref_time_.valid == true)
                {
                    ref_rx_utc_time = static_cast<time_t>(agnss_ref_time_.seconds);
                }

            const std::vector<std::pair<int, Gnss_Satellite>> visible_sats = get_visible_sats(ref_rx_utc_time, ref_LLH);
            // Set the receiver in Standby mode
            flowgraph_->apply_action(0, 10);
            // Give priority to visible satellites in the search list
            flowgraph_->priorize_satellites(visible_sats);
            // Hot Start
            flowgraph_->apply_action(0, 12);
        }
}


void ControlThread::apply_action(unsigned int what)
{
    std::shared_ptr<PvtInterface> pvt_ptr;
    std::vector<std::pair<int, Gnss_Satellite>> visible_satellites;
    applied_actions_++;
    switch (what)
        {
        case 0:
           // LOG(INFO) << "Received action STOP";
            stop_ = true;
            break;
        case 1:
            {
                char messg[] = "Caio: Receiver Restart\n";
                // serial4send(&messg[0]);
                // std::cout << TEXT_BOLD_BLUE << "Caio: Receiver Restart" << TEXT_RESET << "\n";
               // LOG(INFO) << "Received action RESTART";
                stop_ = true;
                restart_ = true;
                break;
            }
        case 10:  // request standby mode
           // LOG(INFO) << "TC request standby mode";
            receiver_on_standby_ = true;
            break;
        case 11:
           // LOG(INFO) << "Receiver action COLDSTART";
            // delete all ephemeris and almanac information from maps (also the PVT map queue)
            pvt_ptr = flowgraph_->get_pvt();
            pvt_ptr->clear_ephemeris();
            // todo: reorder the satellite queues to the receiver default startup order.
            // This is required to allow repeatability. Otherwise the satellite search order will depend on the last tracked satellites
            // start again the satellite acquisitions
            receiver_on_standby_ = false;
            break;
        case 12:
           // LOG(INFO) << "Receiver action HOTSTART";
            visible_satellites = get_visible_sats(cmd_interface_.get_utc_time(), cmd_interface_.get_LLH());
            // reorder the satellite queue to acquire first those visible satellites
            flowgraph_->priorize_satellites(visible_satellites);
            // start again the satellite acquisitions
            receiver_on_standby_ = false;
            break;
        case 13:
           // LOG(INFO) << "Receiver action WARMSTART";
            // delete all ephemeris and almanac information from maps (also the PVT map queue)
            pvt_ptr = flowgraph_->get_pvt();
            pvt_ptr->clear_ephemeris();
            // load the ephemeris and the almanac from XML files (receiver assistance)
            read_assistance_from_XML();
            // call here the function that computes the set of visible satellites and its elevation
            // for the date and time specified by the warm start command and the assisted position
            get_visible_sats(cmd_interface_.get_utc_time(), cmd_interface_.get_LLH());
            // reorder the satellite queue to acquire first those visible satellites
            flowgraph_->priorize_satellites(visible_satellites);
            // start again the satellite acquisitions
            receiver_on_standby_ = false;
            break;
        // Caio
        case 14:
            // std::cout << "Caio: Apply_action()" << "\n";
           // LOG(INFO) << "NavComp. Request PVT";
            serial_cmd_interface_.serial_get_pvt();
            break;
        case 15:
            {
                // std::cout << TEXT_BOLD_BLUE << "Caio: ControlThread::apply_action(15)" << TEXT_RESET << "\n";
                char buf[] = "Caio: ControlThread::apply_action(15)";
                // serial4send(&buf[0]);
                break;
            }
        case 16:
            {
                // std::cout << TEXT_BOLD_BLUE << "Front-End Reset " << TEXT_RESET << "\n";
                char buff[] = "Front-End Reset";
                // serial4send(&buff[0]);
                break;
            }
        case 17:
            {
                // std::cout << TEXT_BOLD_BLUE << "Request Status" << TEXT_RESET << "\n";
                char buff[] = "Status Requested\n";
                // serial4send(&buff[0]);
                // serial_status();
                break;
            }
        case 18:
            {
                // std::cout << TEXT_BOLD_BLUE << "Request Satellites Ephemeris" << TEXT_RESET << "\n";
                char buff[] = "Satellites Ephemeris Requested\n";
                // serial4send(&buff[0]);
                break;
            }
        case 19:
            {
                serial_cmd_interface_.DersoProtocol();
                // serial4send();
                break;
            }
            // default:
            //     {
            //        // LOG(INFO) << "Unrecognized action.";
            //         break;
            //     }
        }
}


std::vector<std::pair<int, Gnss_Satellite>> ControlThread::get_visible_sats(time_t rx_utc_time, const std::array<float, 3> &LLH)
{
    // 1. Compute rx ECEF position from LLH WGS84
    const arma::vec LLH_rad = arma::vec{degtorad(LLH[0]), degtorad(LLH[1]), LLH[2]};
    arma::mat C_tmp = arma::zeros(3, 3);
    arma::vec r_eb_e = arma::zeros(3, 1);
    arma::vec v_eb_e = arma::zeros(3, 1);
    Geo_to_ECEF(LLH_rad, arma::vec{0, 0, 0}, C_tmp, r_eb_e, v_eb_e, C_tmp);

    // 2. Compute rx GPS time from UTC time
    gtime_t utc_gtime;
    utc_gtime.time = rx_utc_time;
    utc_gtime.sec = 0.0;
    const gtime_t gps_gtime = utc2gpst(utc_gtime);

    // 3. loop through all the available ephemeris or almanac and compute satellite positions and elevations
    // store visible satellites in a vector of pairs <int,Gnss_Satellite> to associate an elevation to the each satellite
    std::vector<std::pair<int, Gnss_Satellite>> available_satellites;
    std::vector<unsigned int> visible_gps;
    std::vector<unsigned int> visible_gal;
    const std::shared_ptr<PvtInterface> pvt_ptr = flowgraph_->get_pvt();
    struct tm tstruct
    {
    };
    char buf[80];
    tstruct = *gmtime(&rx_utc_time);
    strftime(buf, sizeof(buf), "%d/%m/%Y %H:%M:%S ", &tstruct);
    const std::string str_time = std::string(buf);
    // std::cout << "Get visible satellites at " << str_time
            //   << "UTC, assuming RX position " << LLH[0] << " [deg], " << LLH[1] << " [deg], " << LLH[2] << " [m]\n";

    const std::map<int, Gps_Ephemeris> gps_eph_map = pvt_ptr->get_gps_ephemeris();
    for (const auto &it : gps_eph_map)
        {
            const eph_t rtklib_eph = eph_to_rtklib(it.second, pre_2009_file_);
            std::array<double, 3> r_sat{};
            double clock_bias_s;
            double sat_pos_variance_m2;
            eph2pos(gps_gtime, &rtklib_eph, r_sat.data(), &clock_bias_s,
                &sat_pos_variance_m2);
            double Az;
            double El;
            double dist_m;
            const arma::vec r_sat_eb_e = arma::vec{r_sat[0], r_sat[1], r_sat[2]};
            const arma::vec dx = r_sat_eb_e - r_eb_e;
            topocent(&Az, &El, &dist_m, r_eb_e, dx);
            // push sat
            if (El > 0)
                {
                    // std::cout << "Using GPS Ephemeris: Sat " << it.second.PRN << " Az: " << Az << " El: " << El << '\n';
                    available_satellites.emplace_back(floor(El),
                        (Gnss_Satellite(std::string("GPS"), it.second.PRN)));
                    visible_gps.push_back(it.second.PRN);
                }
        }

    const std::map<int, Galileo_Ephemeris> gal_eph_map = pvt_ptr->get_galileo_ephemeris();
    for (const auto &it : gal_eph_map)
        {
            const eph_t rtklib_eph = eph_to_rtklib(it.second);
            std::array<double, 3> r_sat{};
            double clock_bias_s;
            double sat_pos_variance_m2;
            eph2pos(gps_gtime, &rtklib_eph, r_sat.data(), &clock_bias_s,
                &sat_pos_variance_m2);
            double Az;
            double El;
            double dist_m;
            const arma::vec r_sat_eb_e = arma::vec{r_sat[0], r_sat[1], r_sat[2]};
            const arma::vec dx = r_sat_eb_e - r_eb_e;
            topocent(&Az, &El, &dist_m, r_eb_e, dx);
            // push sat
            if (El > 0)
                {
                    // std::cout << "Using Galileo Ephemeris: Sat " << it.second.PRN << " Az: " << Az << " El: " << El << '\n';
                    available_satellites.emplace_back(floor(El),
                        (Gnss_Satellite(std::string("Galileo"), it.second.PRN)));
                    visible_gal.push_back(it.second.PRN);
                }
        }

    const std::map<int, Gps_Almanac> gps_alm_map = pvt_ptr->get_gps_almanac();
    for (const auto &it : gps_alm_map)
        {
            const alm_t rtklib_alm = alm_to_rtklib(it.second);
            std::array<double, 3> r_sat{};
            double clock_bias_s;
            gtime_t aux_gtime;
            aux_gtime.time = fmod(utc2gpst(gps_gtime).time + 345600, 604800);
            aux_gtime.sec = 0.0;
            alm2pos(aux_gtime, &rtklib_alm, r_sat.data(), &clock_bias_s);
            double Az;
            double El;
            double dist_m;
            const arma::vec r_sat_eb_e = arma::vec{r_sat[0], r_sat[1], r_sat[2]};
            const arma::vec dx = r_sat_eb_e - r_eb_e;
            topocent(&Az, &El, &dist_m, r_eb_e, dx);
            // push sat
            std::vector<unsigned int>::iterator it2;
            if (El > 0)
                {
                    it2 = std::find(visible_gps.begin(), visible_gps.end(), it.second.PRN);
                    if (it2 == visible_gps.end())
                        {
                            // std::cout << "Using GPS Almanac:  Sat " << it.second.PRN << " Az: " << Az << " El: " << El << '\n';
                            available_satellites.emplace_back(floor(El),
                                (Gnss_Satellite(std::string("GPS"), it.second.PRN)));
                        }
                }
        }

    const std::map<int, Galileo_Almanac> gal_alm_map = pvt_ptr->get_galileo_almanac();
    for (const auto &it : gal_alm_map)
        {
            const alm_t rtklib_alm = alm_to_rtklib(it.second);
            std::array<double, 3> r_sat{};
            double clock_bias_s;
            gtime_t gal_gtime;
            gal_gtime.time = fmod(utc2gpst(gps_gtime).time + 345600, 604800);
            gal_gtime.sec = 0.0;
            alm2pos(gal_gtime, &rtklib_alm, r_sat.data(), &clock_bias_s);
            double Az;
            double El;
            double dist_m;
            const arma::vec r_sat_eb_e = arma::vec{r_sat[0], r_sat[1], r_sat[2]};
            const arma::vec dx = r_sat_eb_e - r_eb_e;
            topocent(&Az, &El, &dist_m, r_eb_e, dx);
            // push sat
            std::vector<unsigned int>::iterator it2;
            if (El > 0)
                {
                    it2 = std::find(visible_gal.begin(), visible_gal.end(), it.second.PRN);
                    if (it2 == visible_gal.end())
                        {
                            // std::cout << "Using Galileo Almanac:  Sat " << it.second.PRN << " Az: " << Az << " El: " << El << '\n';
                            available_satellites.emplace_back(floor(El),
                                (Gnss_Satellite(std::string("Galileo"), it.second.PRN)));
                        }
                }
        }

    // sort the visible satellites in ascending order of elevation
    std::sort(available_satellites.begin(), available_satellites.end(), [](const std::pair<int, Gnss_Satellite> &a, const std::pair<int, Gnss_Satellite> &b) {  // use lambda. Cleaner and easier to read
        return a.first < b.first;
    });
    // provide list starting from satellites with higher elevation
    std::reverse(available_satellites.begin(), available_satellites.end());
    return available_satellites;
}


void ControlThread::gps_acq_assist_data_collector() const
{
    // ############ 1.bis READ EPHEMERIS/UTC_MODE/IONO QUEUE ####################
    Gps_Acq_Assist gps_acq;
    Gps_Acq_Assist gps_acq_old;
    while (stop_ == false)
        {
            global_gps_acq_assist_queue.wait_and_pop(gps_acq);
            if (gps_acq.PRN == 0)
                {
                    break;
                }

            // DEBUG MESSAGE
            // std::cout << "Acquisition assistance record has arrived from SAT ID "
                    //   << gps_acq.PRN
                    //   << " with Doppler "
                    //   << gps_acq.Doppler0
                    //   << " [Hz]\n";
            // insert new acq record to the global ephemeris map
            if (global_gps_acq_assist_map.read(gps_acq.PRN, gps_acq_old))
                {
                    // std::cout << "Acquisition assistance record updated\n";
                    global_gps_acq_assist_map.write(gps_acq.PRN, gps_acq);
                }
            else
                {
                    // insert new acq record
                   // LOG(INFO) << "New acq assist record inserted";
                    global_gps_acq_assist_map.write(gps_acq.PRN, gps_acq);
                }
        }
}


void ControlThread::sysv_queue_listener()
{
    typedef struct
    {
        long mtype;  // NOLINT(google-runtime-int) required by SysV queue messaging
        double stop_message;
    } stop_msgbuf;

    bool read_queue = true;
    stop_msgbuf msg;
    double received_message = 0.0;
    const int msgrcv_size = sizeof(msg.stop_message);

    const key_t key = 1102;

    if ((msqid_ = msgget(key, 0644 | IPC_CREAT)) == -1)
        {
            std::cerr << "GNSS-SDR cannot create SysV message queues\n";
            read_queue = false;
        }

    while (read_queue && !stop_)
        {
            if (msgrcv(msqid_, &msg, msgrcv_size, 1, 0) != -1)
                {
                    received_message = msg.stop_message;
                    if ((std::abs(received_message - (-200.0)) < 10 * std::numeric_limits<double>::epsilon()))
                        {
                            // std::cout << "Quit order received, stopping GNSS-SDR !!\n";
                            control_queue_->push(pmt::make_any(command_event_make(200, 0)));
                            read_queue = false;
                        }
                }
        }
}


void ControlThread::keyboard_listener()
{
    bool read_keys = true;
    char c = '0';
    while (read_keys && !stop_)
        {
            std::cin.get(c);
            if (c == 'q')
                {
                    // std::cout << "Quit keystroke order received, stopping GNSS-SDR !!\n";
                    control_queue_->push(pmt::make_any(command_event_make(200, 0)));
                    stop_ = true;
                    read_keys = false;
                }
            else
                {
                    std::this_thread::sleep_for(std::chrono::milliseconds(100));
                }
        }
}


void ControlThread::print_help_at_exit() const
{
    std::cerr << "Error: the configuration file is not well formatted\n";
    if (!conf_file_has_section_)
        {
            std::cerr << " * The section label has not been found if the configuration file\n"
                      << "   Please add the [GNSS-SDR] label at the top of your configuration file\n"
                      << "   A configuration example is available at https://gnss-sdr.org/my-first-fix/\n";
            return;
        }
    if (!conf_file_has_mandatory_globals_)
        {
            std::cerr << " * Have you forgotten to set the mandatory global parameter GNSS-SDR.internal_fs_sps in your conf file?\n"
                      << "   Documentation about this parameter at https://gnss-sdr.org/docs/sp-blocks/global-parameters/\n"
                      << "   A configuration example is available at https://gnss-sdr.org/my-first-fix/\n";
        }
    if (!conf_has_signal_sources_)
        {
            std::cerr << " * The configuration file must define at least one SignalSource.implementation\n"
                      << "   Documentation of SignalSource block implementations at https://gnss-sdr.org/docs/sp-blocks/signal-source/\n";
        }
    if (!conf_has_observables_)
        {
            std::cerr << " * The configuration file must define an Observables.implementation\n"
                      << "   Documentation of the Observables block at https://gnss-sdr.org/docs/sp-blocks/observables/\n";
        }
    if (!conf_has_pvt_)
        {
            std::cerr << " * The configuration file must define a PVT.implementation\n"
                      << "   Documentation of the PVT block at https://gnss-sdr.org/docs/sp-blocks/pvt/\n";
        }
}



// double ControlThread::deltaprangecomp(void)
// {
//     std::shared_ptr<PvtInterface> pvt_ptr = flowgraph_->get_pvt();
//     std::map<int, Gnss_Synchro> gnss_synchro = pvt_ptr->get_gnss_observables();
//     gnss_synchro.at(0).Carrier_Doppler_hz;
// }


void ControlThread::PPS_GPIO_ctrl(void)
{
    // int line_value = 1;
    // int line;
    // int ret;
    char chip[10];
    // unsigned int offset;
    const char *gpiochip1 = "1";
    snprintf(chip, sizeof(chip), "gpiochip%s", gpiochip1);
    int SODIMM_55 = 18;
    std::shared_ptr<PvtInterface> pvt_ptr = flowgraph_->get_pvt();
    sync = pvt_ptr->get_gnss_observables();
    uint32_t tempo_TOW_current_Symbol_ms;
    uint32_t tempo_1000ms = 1000;
    uint32_t tempo_100ms = 100;
    uint32_t contador{0};
    while (!flag_interrupt_PPS_sig)
        {
            for (const auto &x : sync)
                {
                    tempo_TOW_current_Symbol_ms = x.second.TOW_at_current_symbol_ms;
                    if (tempo_TOW_current_Symbol_ms % tempo_100ms == 0 && (contador == 10))
                        {
                            gpiod_ctxless_set_value(chip, SODIMM_55, 1, false, "gpio-toggle", NULL, NULL);
                            usleep(100000);
                            gpiod_ctxless_set_value(chip, SODIMM_55, 0, false, "gpio-toggle", NULL, NULL);
                            contador=1;
                        }
                        else if(tempo_TOW_current_Symbol_ms % tempo_100ms == 0 &&(contador!=10)){contador++;}
                        else{continue;}
                }
        }
}